# LeetCode 1375 解谜：当灯泡序列“完美点亮”时

大家好！今天我们来聊一道很有意思的 LeetCode 题目——第 1375 题 "灯泡开关 III" (Bulb Switcher III)。别看它名字普通，里面可藏着巧妙的解题思路呢！

## 1. 题目初见：点亮灯泡的“完美时刻”

想象一下，你有一排编号从 1到 N 的灯泡，一开始都是灭的。你手里有一张操作清单 `flips`，告诉你每次按顺序点亮哪个灯泡。

**题目描述**：
> 你有一个长度为 `n` 的灯泡数组 `bulbs`，编号从 1 到 `n`，所有初始都是关闭状态。
> 给你一个数组 `flips`，表示每次你会打开编号为 `flips[i]` 的灯泡。`flips` 数组是 `[1, 2, ..., n]` 的一个排列。
> 每次打开一个灯泡后，如果从第一个灯泡到**目前已点亮灯泡中编号最大的那个灯泡**为止，这个区间内的所有灯泡都处于点亮状态，那么这一刻就叫做“所有前缀变蓝”（或者说“完美点亮”）。
> 问：在整个操作过程中，总共会出现多少次这样的“完美点亮”时刻？

**难度等级**：中等
**题型分类**：数组、模拟、贪心

**举个栗子**：
假设 `flips = [2, 1, 3, 5, 4]`，`n=5`。
1.  **点亮 `flips[0] = 2`**：
    *   已点亮灯泡：`{2}`。
    *   最右点亮的是 2 号灯。
    *   检查 1 号到 2 号灯：1 号灭，2 号亮。不满足“前缀全亮”。
2.  **点亮 `flips[1] = 1`**：
    *   已点亮灯泡：`{1, 2}`。
    *   最右点亮的是 2 号灯。
    *   检查 1 号到 2 号灯：1 号亮，2 号亮。满足！这是一个“完美点亮”时刻。计数+1。
3.  **点亮 `flips[2] = 3`**：
    *   已点亮灯泡：`{1, 2, 3}`。
    *   最右点亮的是 3 号灯。
    *   检查 1 号到 3 号灯：全亮。满足！计数+1。
4.  **点亮 `flips[3] = 5`**：
    *   已点亮灯泡：`{1, 2, 3, 5}`。
    *   最右点亮的是 5 号灯。
    *   检查 1 号到 5 号灯：4 号灭。不满足。
5.  **点亮 `flips[4] = 4`**：
    *   已点亮灯泡：`{1, 2, 3, 4, 5}`。
    *   最右点亮的是 5 号灯。
    *   检查 1 号到 5 号灯：全亮。满足！计数+1。

总共有 3 个“完美点亮”时刻。

是不是有点感觉了？这题目就像是在问，我们按特定顺序插上一串彩灯，啥时候从第一盏到最远那盏插上的灯，中间一个不落全都亮起来了？

## 2. 题型特征与识别：一眼看穿“套路”

这类问题通常有一些共同点，学会识别它们，就能更快找到解题方向。

*   **输入输出特征**：
    *   输入：一个数组（通常是整数），代表操作序列或元素集合。这里 `flips` 是一个 1 到 `n` 的排列，这点非常关键！
    *   输出：一个计数，代表满足某种“全局”或“前缀”条件的时刻数量。
*   **关键词**：
    *   “按顺序操作”、“逐步”、“状态变化”。
    *   “前缀”、“连续”、“所有”、“区间”。
    *   “最大编号”、“最右侧”。
    *   “排列” (Permutation)：这个词暗示了元素不重复且范围固定，是重要线索。
*   **常见陷阱**：
    *   **状态跟踪复杂化**：可能会想用一个布尔数组记录每个灯泡的亮灭状态，然后每次都遍历检查。对于大数据量，这可能超时。
    *   **“最右”的误解**：题目中的“目前已点亮灯泡中编号最大的那个灯泡”指的是所有已点亮灯泡里的最大编号，而不是当前这一步点亮的灯泡编号。
    *   **忽略“排列”特性**：如果 `flips` 不是排列，问题会复杂得多。排列特性是解题的钥匙。

**识题技巧：“计数与边界对齐”**
当你看到题目涉及到：
1.  逐步处理一个序列。
2.  需要维护一个“已处理元素”的某种边界特征（如最大值、最小值）。
3.  判断条件与“已处理元素的数量”和这个“边界特征”相关。

特别是当输入是 **1 到 N 的排列** 时，如果“已处理元素的数量”恰好等于“这些元素中的最大值”，往往意味着一个特殊的、有序的“完整”状态达成了。就像我们这道题，如果点亮了 `k` 个灯泡，而这 `k` 个灯泡中最大的编号恰好是 `k`，那么这 `k` 个灯泡一定是 1 号到 `k` 号！

## 3. 解题思路剖析：从“蛮力”到“聪明”

我们一步步来看怎么解决这个问题。

**思路一：朴素模拟 (暴力法)**

最直观的想法就是完全按照题目描述来模拟：
1.  维护一个布尔数组 `is_on[1...n]`，记录每个灯泡的亮灭状态。
2.  在每一步 `i`（点亮 `flips[i]` 灯泡）：
    a.  将 `is_on[flips[i]]` 设为 `true`。
    b.  遍历 `is_on` 数组，找到当前所有已点亮灯泡中的最大编号 `max_lit_bulb`。
    c.  再从 1 号灯泡检查到 `max_lit_bulb` 号灯泡，看是否都 `is_on`。
    d.  如果都亮，则计数器加一。

*   **复杂度分析**：
    *   共有 `N` 步操作。
    *   每一步：更新 `is_on` 是 `O(1)`。找 `max_lit_bulb` 最坏可能是 `O(N)`（如果每次都从头找，或者 `O(i)` 如果只看已亮的）。检查前缀是 `O(max_lit_bulb)`，也就是 `O(N)`。
    *   总体复杂度大约是 `O(N^2)`。对于 `N` 高达 `5 * 10^4` 的情况，`N^2` 就是 `2.5 * 10^9`，肯定超时！

**思路二：优化状态跟踪**

`O(N^2)` 不行，我们得优化。关键在于如何高效判断“前缀全亮”。

*   **优化 `max_lit_bulb` 的计算**：我们不需要每次都重新扫描。可以在迭代过程中维护一个变量 `rightmost_on_bulb`，表示到目前为止点亮过的灯泡的最大编号。每次点亮一个新灯泡 `current_bulb = flips[i]`，就更新 `rightmost_on_bulb = max(rightmost_on_bulb, current_bulb)`。这变成了 `O(1)` 操作。

*   **核心洞察：排列的魔力！**
    这是解题的关键！题目说 `flips` 是 `1` 到 `n` 的一个排列。
    思考一下：
    *   我们总共点亮了多少个灯泡？在第 `k` 步（0-indexed的话是 `i` 步，点亮了 `i+1` 个灯泡），我们就点亮了 `k` (或 `i+1`) 个灯泡。
    *   这些已点亮的灯泡中，最大的编号是多少？就是我们维护的 `rightmost_on_bulb`。

    **如果，在点亮了 `count_lit` 个灯泡后，这些灯泡中最大的编号 `rightmost_on_bulb` 恰好也等于 `count_lit`，这意味着什么？**

    这意味着，这 `count_lit` 个灯泡，不多不少，正好是编号从 `1` 到 `count_lit` 的所有灯泡！
    为什么呢？因为 `flips` 是个排列，没有重复的灯泡编号。如果你点亮了 `count_lit` 个不同的灯泡，它们的最大编号是 `count_lit`，那这些灯泡只能是 `1, 2, ..., count_lit`。不可能有遗漏（比如少了 `2` 号但最大是 `count_lit`，那你就凑不够 `count_lit` 个灯泡了），也不可能有更大的编号（因为最大就是 `count_lit`）。

    **生活中的类比**：
    想象你在收集一套限量版卡片，编号从 1 到 N。你每次随机拿到一张（但保证不重复，最后会集齐）。
    *   `count_lit`：你已经拿到的卡片数量。
    *   `rightmost_on_bulb`：你已拿到卡片中编号最大的那张。
    如果某时，你发现自己手里有 5 张卡片，并且编号最大的那张恰好是 5 号卡。这说明什么？说明你手里的肯定是 1、2、3、4、5 号卡！如果少了任何一张（比如没有3号），或者最大号不是5（比如是7号），这个等式 (`数量 == 最大编号`) 就不成立了。

**思路三：最终算法 (O(N) 解法)**

基于这个核心洞察，算法就非常简洁了：
1.  初始化 `blue_moments = 0` (完美时刻计数)。
2.  初始化 `rightmost_on_bulb = 0` (记录已点亮灯泡的最大编号)。
3.  遍历 `flips` 数组，设当前是第 `step` 次操作 (从1开始计数，或者说，已点亮 `step` 个灯泡)。
    *   在第 `i` 次迭代 (0-indexed, `flips[i]` 是当前点亮的灯泡)：
        a.  `num_bulbs_on = i + 1` (这是我们已经点亮的灯泡总数)。
        b.  `current_bulb = flips[i]`.\
        c.  更新 `rightmost_on_bulb = max(rightmost_on_bulb, current_bulb)`.\
        d.  **判断关键条件**：如果 `rightmost_on_bulb == num_bulbs_on`，那么这就是一个“完美点亮”时刻！`blue_moments` 加一。\
4.  返回 `blue_moments`。

*   **复杂度分析**：
    *   时间复杂度：我们只遍历了一遍 `flips` 数组，每一步都是常数时间操作。所以是 `O(N)`。
    *   空间复杂度：只用了几个变量来存储状态，所以是 `O(1)` (不包括输入数组本身)。

这个解法是不是既简单又高效？

**图解一下 `flips = [2, 1, 3, 5, 4]` 的过程：**

| 步骤 (i) | `flips[i]` | `num_bulbs_on` (i+1) | `rightmost_on_bulb` (更新后) | `rightmost_on_bulb == num_bulbs_on`? | `blue_moments` |
| :------- | :--------- | :------------------- | :--------------------------------- | :--------------------------------- | :------------- |
| 0        | 2          | 1                    | `max(0, 2) = 2`                    | `2 != 1` (No)                      | 0              |
| 1        | 1          | 2                    | `max(2, 1) = 2`                    | `2 == 2` (Yes!)                    | 1              |
| 2        | 3          | 3                    | `max(2, 3) = 3`                    | `3 == 3` (Yes!)                    | 2              |
| 3        | 5          | 4                    | `max(3, 5) = 5`                    | `5 != 4` (No)                      | 2              |
| 4        | 4          | 5                    | `max(5, 4) = 5`                    | `5 == 5` (Yes!)                    | 3              |

结果正确！

**常见错误点或思维误区回顾**：
*   **过度设计状态**：一开始容易想到用一个完整的数组 `bool states[N]` 来表示每个灯泡的状态，但其实我们只需要 `rightmost_on_bulb` 和 `num_bulbs_on` 这两个信息。
*   **不相信“排列”的力量**：如果 `flips` 不是排列，`rightmost_on_bulb == num_bulbs_on` 这个条件就不一定能保证 `1...num_bulbs_on` 都亮了。但因为它是排列，这个捷径才成立。

## 4. 总结解法通用技巧：“状态计数与边界匹配”

这道题给我们展示了一种常见的解题模式，我们可以称之为“状态计数与边界匹配”。

*   **通用套路/思维路径**：
    1.  **明确目标状态**：首先搞清楚题目要求我们识别或计数的是一种什么样的“特殊状态”或“完美时刻”。（比如本题的“前缀全亮”）
    2.  **识别关键变量**：找出描述这个状态最核心的几个变量。通常会包括：
        *   一个“计数器”变量：代表已经处理/激活/点亮的元素数量 (如 `num_bulbs_on`)。
        *   一个“边界”变量：代表已处理元素中的某种极值或特征 (如 `rightmost_on_bulb`)。
    3.  **寻找简化条件**：利用题目给定的约束（如输入是排列、元素范围等），看是否能简化判断“目标状态”的条件。本题中，`rightmost_on_bulb == num_bulbs_on` 就是利用排列特性得到的简化条件。
    4.  **迭代更新与检查**：在遍历输入数据的过程中，每一步都高效地更新这些关键变量，并检查是否满足简化后的条件。

*   **关键词 + 触发思维方式**：
    *   **“排列 (Permutation) of 1..N” + “已处理 K 个元素” + “最大元素是 K”**  =>  触发思考：这 K 个元素就是 1 到 K。
    *   **“逐步过程” + “前缀条件”** => 触发思考：能否通过维护少量状态，在每一步 O(1) 判断前缀条件？

这个思想在很多数组、序列处理问题中都很有用。

## 5. 延伸：相似题目练练手

掌握了这个技巧，我们来看看其他几道题目是否也能触类旁通。

1.  **LeetCode 769. Max Chunks To Make Sorted (最多能完成排序的块)**
    *   **题目大意**：给定一个 `0` 到 `arr.length - 1` 的排列 `arr`。将数组分成若干“块”，每块单独排序后拼接起来，如果能得到整个数组的排序结果，问最多能分多少块。
    *   **如何应用技巧**：这题和灯泡题惊人地相似！我们遍历数组 `arr`，维护一个 `max_val_in_chunk` (当前块中遇到的最大元素值)。如果遍历到索引 `i` 时，`max_val_in_chunk == i`，这意味着 `arr[0...i]` 这些元素恰好是 `0...i` 的一个排列（只是顺序可能乱了）。此时，`arr[0...i]` 就可以形成一个独立的块，排序后能保证是 `0...i`。
    *   **比较**：核心逻辑几乎一样，都是“已处理元素数量”（这里是 `i+1` 个元素，最大索引是 `i`）和“已处理元素中的最大值”之间的匹配。

2.  **LeetCode 798. Smallest Rotation with Highest Score (得分最高的最小轮调)**
    *   **题目大意**：给定一个数组 A，我们可以选择一个 K 进行轮调，轮调后新数组 B 中，满足 `B[i] <= i` 的元素会得分。求能获得最高分的最小 K。
    *   **如何应用技巧 (间接)**：虽然不是直接的“计数与边界匹配”，但这题通常用差分数组来解决。差分数组的思想是，当一个操作对一个区间产生影响时，我们只在区间的端点记录变化。这和我们关注“边界”和“状态变化”有异曲同工之妙。你需要分析每个元素在不同轮调 K 值下，何时开始得分，何时结束得分，从而找到最优 K。

3.  **LeetCode 45. Jump Game II (跳跃游戏 II)**
    *   **题目大意**：给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。
    *   **如何应用技巧**：这是一个贪心问题。在每一步，我们都想跳到能让我们下一次跳得更远的位置。我们需要维护当前能到达的最远位置 `current_farthest` 和上一步能跳到的边界 `last_jump_max_reach`。当遍历超过 `last_jump_max_reach` 时，说明必须进行下一次跳跃了，跳跃次数加一，同时更新 `last_jump_max_reach` 为 `current_farthest`。
    *   **比较**：这里也是通过维护“边界”（能到达的最远位置）和“计数”（跳跃次数）来逐步推进。

这些题目虽然各有侧重，但“迭代中维护状态、关注边界条件、利用输入特性简化判断”的思维方式是相通的。

## 6. 总结与鼓励

好啦，关于 LeetCode 1375 "灯泡开关 III" 的探讨就到这里。希望通过这道题，你不仅学会了一个具体的解法，更能体会到：

*   **观察题目特性** (比如“排列”) 是多么重要。
*   **简化判断条件** 是算法优化的核心。
*   很多看似复杂的问题，其核心逻辑可能非常简洁，关键在于找到那个“**啊哈！时刻**”的洞察。

刷题就像是在侦探破案，每一个条件都是线索，每一次思考都是推理。多练习，多总结，你也能成为一名出色的“算法侦探”！下次遇到类似“逐步处理序列，判断前缀/区间状态”的问题，不妨想想今天我们聊到的“计数与边界匹配”的思路。

希望这篇文章对你有帮助！如果你有任何想法或疑问，欢迎在评论区交流。下次再见！
