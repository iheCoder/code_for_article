

# 驾驭复杂：领域驱动设计（DDD）战略、战术与治理全景指南



## 第 0 章：引言——为什么 DDD 是我们对抗复杂度的终极武器

软件工程的最大敌人之一是**复杂度**，尤其是那种随着时间积累、慢慢腐蚀系统的复杂度。你也许遇到过这样的场景：

- 改一个小需求，需要动几十个类。
- 新人看代码半天，发现“下单”逻辑居然分散在 UI 层、Service 层和几张表的触发器里。
- 业务方说“订单取消”是 A 流程，代码里却是 B 流程。

这就是所谓的**代码腐化**：最初清晰的业务逻辑，被技术细节、临时补丁和跨模块的依赖一点点侵蚀。

**领域驱动设计（Domain-Driven Design, DDD）**试图解决的，就是这种“业务逻辑迷失在代码细节里”的问题。

一句话总结：

> DDD 是一种**用业务语言组织软件的结构和行为**的设计方法。

这意味着：

1. **业务语言优先**：开发团队和业务团队使用相同的“通用语言”描述问题。
2. **模型优先**：系统的核心结构源自领域模型，而不是数据库表或框架模板。
3. **边界明确**：不同的业务语境（上下文）在代码中也有明确的边界，互不污染。



#### 什么时候用 DDD？

- **值得用**：业务逻辑复杂、多团队协作、需求频繁变化的系统（电商平台、网约车、金融结算等）。
- **不必用**：简单 CRUD 系统、原型验证项目、小范围一次性脚本。



#### 常见误解：

- **DDD 不是微服务**：它关注的是业务建模，微服务只是其中一种落地方式。
- **DDD 不是画图**：它更关注团队如何对齐语言和模型，而不是产出 UML。
- **DDD 不是银弹**：它能帮你管理复杂度，但不能消除业务本身的复杂性。



## 第一部分：战略设计 —— 先把边界划对，再谈代码优雅

战略设计是 DDD 的宏观布局，它回答三个根问题：

1. 我们的业务世界怎么切成有意义的**子域**？
2. 每块子域内，软件该如何定义**限界上下文**（模型与语言的边界）？
3. 这些上下文之间**如何协作**，既高效又不相互污染？



### 第 1 章：核心概念辨析

#### 1.1 领域（Domain）、模型（Model）与通用语言（Ubiquitous Language）

- **领域（Domain）**：“领域”就是你要解决问题的那块业务世界，比如网约车的“行程管理”、电商的“库存管理”。领域不仅是名词，更包含业务规则、流程和约束。

- **模型（Model）**：模型是对领域的抽象，把现实世界的业务用代码可以表达的方式表示出来。例如，“订单”在现实中是纸质单据，在系统中可能是一个有状态机、方法和不变量的对象。

- **通用语言（Ubiquitous Language）**：这是团队共同使用的、精确且一致的业务语言。

    - 产品说“司机接单”，
    - 程序员代码里方法名就叫 `AcceptAssignment()`，
    - 测试用例里也叫“司机接单”，而不是“ConfirmDriverTask”。

  这样能有效避免“术语翻译”过程中的信息损失。



#### 1.2 子域（Subdomain）与限界上下文（Bounded Context）

这是很多人最容易混淆的地方。

- **子域**：是战略层面的**业务划分**，关注**业务能力**。它是**问题空间**的划分。
    - 网约车的子域可能有：定价（Pricing）、派单（Dispatch）、地图（Mapping）、行程（Trip）、结算（Settlement）。
    - 子域是面向业务战略的，和代码结构没有必然对应关系。
- **限界上下文**：是软件实现层面的**模型边界**，关注**模型与语言的一致性**。它是**解决方案空间**的划分。
    - 在“派单”子域中，可能有两个限界上下文：
        - **实时派单（Real-time Dispatch）**：负责实时分配司机。
        - **批量调度（Batch Dispatch）**：用于拼车或特殊活动。
    - 这两个上下文都有“派单”这个词，但在各自边界内有不同的模型和规则。

**关系**：一个子域可以有一个或多个限界上下文。限界上下文是子域在实现层面上的**防护罩**，防止外部污染内部语言与规则。



### 第 2 章：识别子域与划分上下文

#### 2.1 识别子域：从“业务能力”出发，而非“表结构”



**子域（Subdomain）= 业务能力的分区**。目标是把“真正不同的问题”拆开，让每块都有自己的术语、目标与节奏。

**子域类型**：

- **核心子域（Core）**：业务竞争力的关键（网约车的派单算法）。
- **支撑子域（Supporting）**：为核心子域提供支撑（司机评分系统）。
- **通用子域（Generic）**：通用能力（用户登录、支付网关）。

**网约车的子域清单（示例）**

- **核心（Core）**：派单（Dispatch/Matching）、动态定价（Pricing/Surge）、行程（Trip Orchestration）
- **支撑（Supporting）**：司机画像与合规、乘客信用与风控、激励与补贴、客服
- **通用（Generic）**：账号与认证、支付网关、计费基础库、通知/短信

> ##### 经验法则（三问）
>
>
>
> 1. 这块能力是否决定公司差异化？若是，往“核心”放。
> 2. 若把它外包/购买第三方会不会“失去灵魂”？若不会，多半是“通用”。
> 3. 它是否只是帮助核心跑得更稳/更快？那就是“支撑”。

**识别子域的实操招式**：

- **事件风暴（Event Storming）**：先铺“发生了什么（领域事件）”，再逆推“谁触发（命令）”“谁负责（聚合/上下文）”。
- **价值流（Value Stream）**：围绕“请求→完成”的端到端路径，找出价值断点（不同优化目标的段落就是不同子域）。
- **语言差异**：若同一个词在不同团队说的不是一回事，极可能跨子域。



#### 2.2 限界上下文：让模型与语言“各安其位”

**限界上下文（Bounded Context）= 模型与通用语言的防护罩**。在边界内，术语有唯一含义；边界外，即使同词不同义也互不干扰。

从子域到上下文的“进一步切分”

同一子域内部，若出现以下信号，应切为多个上下文：

- **语言漂移**：定价里“价格”=报价算法输出；结算里“价格”=结算金额；不要用一个对象到处跑。
- **一致性强度不同**：派单匹配需要秒级决策与局部一致；结算则强调账务正确与可追溯。
- **变更节奏不同**：实验性算法 vs 审计合规模块，发布频率与回滚策略完全不同。
- **团队边界**：一个团队一门语言一套模型，避免“谁都能改”的公共地带。

**网约车中的上下文草图（示例）**

```
[乘客体验上下文] —— 请求/展示/评价（App体验、文案与A/B）
        │
        ▼（命令）
[Trip编排上下文] —— 乘客发单/行程状态机、不变量守护
        │
        ├──►（查询/订阅） [ETA&地图上下文] —— 路径估算、ETA、地理栅格
        ├──►（请求-响应） [动态定价上下文] —— 报价、溢价、封顶规则
        └──►（事件）       [派单上下文] —— 实时匹配、司机可用性
                 │
                 └──►（事件）[司机位置上下文] —— 位置更新流
        ▼（事件）
[结算上下文] —— 费用确认、发票、对账
        ▼
[支付网关上下文] —— 第三方支付对接（通用）
```



### 第 3 章：上下文映射（Context Map）：把“关系”说清楚



上下文映射描述的是**上游/下游**关系与**协作契约**。常用模式至少要掌握这四个，并补充两个进阶模式。



#### 3.1 共享内核（Shared Kernel）

- **定义**：两个上下文**共同维护**一小块“共享模型/库”，通常是不可分割的核心概念（比如统一的“用户ID规范”“地理网格编码”）。

- **何时用**：双方对这块模型的语义高度一致，且都承受不了分叉后带来的转换成本。

- **风险**：耦合极强，任何变更需要**双边同步发布**，容易成为“隐性公共仓”。

- **治理建议**：



- 缩小共享范围；
- 独立版本与契约测试；
- 设“双签字人”（两上下文的负责人共同审批变更）。



#### 3.2 伙伴关系（Partnership）

- **定义**：两个上下文强协同、共同交付一条价值流；路线图与发布节奏协同。
- **场景**：Trip编排 与 派单 在早期常是伙伴关系，一起迭代行程状态与匹配策略。
- **优点**：跨团队摩擦小，业务推进快。
- **代价**：组织成本高，对齐成本大；适合长期紧密协作的阶段，而非永恒状态。



#### 3.3 客户-供应商 & 顺从者（Customer–Supplier & Conformist）



- **定义**：当你依赖的上游（供应商）很强势或已成事实标准，你（客户）只能**顺从（Conformist）**其模型与接口。
- **例子**：支付网关就是供应商；结算上下文往往顺从其对账语义与回调协议。
- **优点**：集成简单、认清现实。
- **代价**：上游改变就得跟着变；你的领域语言被迫“硬拗”成上游语言。



#### 3.4 防腐层（Anti-Corruption Layer, ACL）

- **定义**：在你的上下文边界加一层**翻译/保护**，把外部模型转成你的通用语言，并隔离其怪癖。
- **用途**：接入遗留系统、第三方系统，或不想顺从强势上游时。
- **实现手法**：适配器（Adapter）、翻译器（Translator）、门面（Facade）、映射表、稳定的中间DTO、错误语义映射。
- **代价**：多一层代码与运维，但换来模型纯净与可测试性。

> #### 进阶两招（常被忽略但很有用）
>
>
>
> - **Open Host Service（开放主机服务）**：下游很多，上游提供**通用协议**（如GraphQL/REST约定）而非定制接口。
> - **Published Language（发布语言）**：把集成语言（Schema/事件格式）文档化并版本化，避免“口口相传”式集成。

**网约车的上下文映射（示意）**

```
Pricing ──(Open Host Service + Published Language/报价Schema)──► Trip编排（Customer）
   ▲
   │（Partnership：与派单在早期共同演进对“可接单性”的定义）
   │
Dispatch ◄──(Shared Kernel：地理栅格编码/司机可用性字典，范围极小)──► Driver-Location
   │
   └──► Settlement（Customer） ——(ACL：把“订单费用项”映射成“结算行条目”)──► 支付网关（Supplier，强势）
```



### 第 4 章：战略设计的工程考量

#### 4.1 事务边界与一致性：跨上下文不要做分布式大事务

**基本原则**：**聚合内强一致，跨上下文靠事件驱动实现最终一致**。战略设计阶段必须决定跨上下文的“时间与正确性的交易”。

**强一致 vs 最终一致（在网约车）**

- **强一致**（一个上下文内部）：
    - 派单上下文：一个司机同一时间只能被分配一个行程（不变量）。
- **最终一致**（跨上下文）：
    - “Trip创建→Pricing出报价→用户确认”允许几百毫秒的松动。
    - “Trip完成→结算→支付”允许秒级甚至分钟级重试与补偿。

**事件与编排**

- **领域事件**（事实广播）：`TripCompleted`, `DriverAssigned`, `FareCalculated`
- **Outbox/事务消息**：写业务表=写Outbox表（同一事务），由消息中继可靠投递。
- **幂等与去重**：事件消费者以业务键去重（如 `TripID` + `Version`）。
- **补偿（Saga/Process Manager）**：支付失败→生成欠费账、触发催付与客服任务，而不是回滚整个世界。

> #### 选择指南
>
>
>
> - 若“绝对不能出错”，不要跨上下文做大事务；把“正确结算”设计成独立的、可重试的**后置流程**。
> - 给每条“最终一致链路”定义**时限与可见性**（SLA & 用户体验），例如“行程完成后1分钟内看到账单”。



#### 4.2 同部署与拆微服务：部署不是建模，过早拆分会挨打

**模块化单体（先） vs 微服务（后）**

- **建议路线**：先把**限界上下文作为模块/包**在单体内实现，接口走**同步/内存调用**；当某上下文在**规模、吞吐或团队独立性**上有硬需求，再拆成服务。
- **原因**：边界还不稳时网络分布只会放大成本；单体内也能“上下文隔离”（包边界+编译时依赖控制）。
- **拆分信号**：独立扩缩容；发布频率与回滚策略不同；拥有独立的数据生命周期与合规要求。

**集成风格：同步 vs 异步**

- **同步（RPC/REST）**：请求-响应、低延迟；风险是**级联失败**与**脆弱耦合**。
- **异步（事件/消息）**：松耦合、弹性好；代价是可观测性与一致性处理复杂。
- **实用建议**：查询走同步（必要时缓存）；状态传播走异步事件；所有跨上下文调用都要有**超时、重试、熔断、隔离**。



#### 4.3 组织映射：用康威定律“顺水推舟”

- **一个上下文 ≈ 一个长期稳定团队**。语言、测试、发布、度量都围绕它。
- 避免“共享平台团队同时改遍全场”的组织形态；平台团队更像**供应商**（提供Open Host Service + Published Language）。
- 设立**业务架构审查**，只评“边界与协作”，不评“技术栈喜好”。



### 小结

- **子域**决定“我们在打哪些不同的仗”。
- **限界上下文**决定“每场仗的战壕在哪儿挖”。
- **上下文映射**决定“友军如何协同、敌军如何隔离”。
- **一致性策略**决定“遇到风浪，船怎么稳住”。
- **部署形态**是最后的工程选择，不要让它反过来决定模型。

## 第二部分：战术设计 —— 用“聚合”把业务规则写进代码



> **导航提示**：本章将讲清楚四件事：
>
> - 实体、值对象、**聚合**、**聚合根**到底是什么
> - 为什么必须用“聚合”守住**业务不变量**
> - 在项目里**一步步**把规则落成代码
> - 以及常见疑问与判断标准。



### 第 1 章：战术设计的核心构建块

#### 1.1 概念全图（先把地图挂墙上）

- **实体（Entity）**：有**身份（ID）**、会变。例：行程 Trip、司机 Driver。
- **值对象（Value Object）**：只看取值、**不可变**、可相等比较。例：金额 Money，坐标 Location。
- **聚合（Aggregate）**：一组强相关实体和值对象，围出一个**业务不变量的保护边界**；边界内的修改要么全成要么全败。
- **聚合根（Aggregate Root）**：聚合对外的“**唯一入口**”。外部只能通过它修改聚合；根负责检查并**捍卫不变量**，并**发布领域事件**。

> #### 一句比喻：
>
>
>
> 聚合是“院子”，不变量是“院规”，聚合根是“院门与门卫”。来访必须走正门（方法），门卫检查（校验规则），违规进出不可能发生（事务）。



#### 1.2 为什么非“聚合”不可？—— 因为你需要一个原子边界守住不变量

**业务不变量（Invariant）**是“无论何时都必须成立”的规则。

在网约车里，典型不变量有：

1. 一个 Trip 同一时刻**最多有一个**有效司机指派。
2. Trip 状态只能沿合法状态机迁移。
3. 价格一旦锁定（FareLocked）就不能被悄悄改掉。

这些规则不是“建议”，而是**法律**。要保证法律不被任何调用路径绕过，就需要一个**原子修改的围栏**。这就是聚合的意义：

- **写入的原子性**：修改聚合内多处状态时，要么一起成功，要么一起失败。
- **语义的中心化**：所有会触发不变量检查的动作，都经由聚合根的方法表达（AssignDriver、Complete、LockFare）。
- **系统的可推理性**：读代码时，不变量在**一个地方**被守护，测试也能对准这一处。

> **判断题**：如果一次业务操作必须“要么同时完成 X、Y、Z，要么都别发生”，那 X/Y/Z 很可能属于**同一个聚合**。



### 第 2 章：设计与实现聚合

#### 2.1 怎么把“院子”画出来：从不变量出发的 6 步法

以 Trip（行程）为例，演示一遍从 0 到 1：

- **第 1 步：列出不变量（要“强硬”而非“建议”）**

    - T1：Trip 在进行中最多一个有效 Assignment。
    - T2：Trip 状态机：Requested → Assigned → EnRoute → Completed/Cancelled（不可回退）。
    - T3：FareLocked 之后总价不可改，需走“补价流程”。

- **第 2 步：找“原子变更”**（一次命令里必须一起完成的状态变化）

    - C1：分配司机：创建/激活 Assignment + 状态从 Requested/Assigned → Assigned。
    - C2：锁价：写入总价 + 标记 FareLocked。
    - C3：完单：Assigned/EnRoute → Completed + 记账总价 + 产生完成事件。

- **第 3 步：确定聚合边界**

    - Trip 自己 + 它的 Assignment（“谁接单”）在同一聚合，因为 C1 必须原子化。
    - 司机可用性（DriverAvailability）不进来，因为它属于另一个不变量，这是**另一个院子**，靠**事件**协作。

- **第 4 步：选出聚合根（谁当“门”）**

    - 让 **Trip 当根**：因为所有不变量都以 Trip 为中心表达。
    - 外界不可直接操作 Assignment，只能通过 `Trip.AssignDriver(...)` 触发。

- **第 5 步：把命令写成“有意义的方法”**

    - `trip.AssignDriver(driverID, eta)`

    - `trip.LockFare(total)`

    - trip.Complete(at)

      方法名用通用语言（业务话术），而不是 UpdateXXX 这类技术话。

- **第 6 步：在方法里“先查院规 → 再改状态 → 发事件”**

    - 失败就抛业务异常（如 `ErrAlreadyAssigned`），由**应用层**决定是否补偿/重试。
    - 成功就把事实以**领域事件**记下来（`DriverAssigned`, `FareLocked`, `TripCompleted`）。



#### 2.2 聚合根到底做什么？三条硬规矩

1. **唯一入口**：任何外部修改都走根的方法；根之外的内部实体**不被外部持有引用**（最多用 ID 表示）。
2. **守不变量**：根的方法里**先判断、再改动**，确保不变量永远成立。
3. **发事实**：根在本地修改后，**立刻**记录“发生了什么”（领域事件），供跨聚合/跨上下文反应。

直观对比

❌ 脚本式（反例）：

```
// 反例：到处直改字段，没人守不变量
trip.assign = &Assignment{Driver: d, IsActive: true}
trip.status = Assigned
// 忘了发事件，忘了检查已有指派……
```

**✅ 聚合根式：**

```
func (t *Trip) AssignDriver(d DriverID, eta ETA, now time.Time) error {
	if t.status != Requested && t.status != Assigned { return ErrInvalidState }
	if t.assign != nil && t.assign.IsActive { return ErrAlreadyAssigned } // 守“不同时多指派”
	t.assign = &Assignment{Driver: d, ETA: eta, IsActive: true}
	t.status = Assigned
	t.raise(DriverAssigned{Trip: t.id, Driver: d, At: now})
	return nil
}
```



#### 2.3 “行为入内，脚本在外”：放置逻辑的标尺

给你一把**放置逻辑的尺子**（从内到外，能放内层就不放外层）：

- **层 1：值对象（最内层）**：纯计算、无身份、可复用的规则。例：`Money.Add()` 校验币种一致。
- **层 2：聚合根方法**：任何会触发**不变量**检查或状态机迁移的行为。例：`Trip.AssignDriver()`。
- **层 3：领域服务（Domain Service）**：规则涉及**多个聚合**或要访问外部领域（但仍然是**纯领域语义**）。例：`FareService.LockFareForTrip(trip)`。
- **层 4：应用服务（App Service）**：**编排**命令：加载聚合 → 调方法 → 保存 → 发布事件。不写业务规则，不决策不变量。

> **一句话记忆：能进对象就别放服务，能进聚合就别放应用。**



#### 2.4 领域事件：让事实以可订阅的方式发声

- **是什么**：过去式的业务事实，例如 `DriverAssigned`, `TripCompleted`。
- **为什么**：让**跨聚合/跨上下文**在松耦合下协作；让系统具有“**业务可观测性**”。
- **怎么做**：
    1. **写入与事件同事务**（出库/Outbox），避免“有状态没事件”。
    2. **只带必要字段**（业务键、发生时间、少量上下文）。
    3. **幂等 & 去重**（`(AggregateID, Version)` 或 `EventID`）。
    4. **命名用完成体**（过去式），避免“到底发生了没”的歧义。



#### 2.5 规格（Specification）与策略（Policy）：把“易变”从“硬核”里拆出来

- **规格**：可组合的布尔条件（`IsCompliant AND NearBy(2km) AND Online≥10min`）。
- **策略**：多方案里选其一（`Nearest` vs `HighestScore` 匹配）。
- **用法**：把筛选与选择写成**可替换的部件**，A/B 或配置只换部件，不改聚合硬逻辑。聚合根只关心“是否符合院规”，至于院规细则（规格/策略实现）可以热插拔。



### 第 3 章：战术设计落地清单与 Q&A

#### 3.1 建一个聚合的 8 条清单



1. 写出**三条以上**不变量（越“强硬”越好）。
2. 列出**原子变更**（一条命令里必须同时完成的改动）。
3. 决定边界：只把与原子变更**强耦合**的状态装进聚合；其他用 ID 关联。
4. 选根：谁能作为**唯一入口**覆盖全部不变量。
5. 定方法：方法名用**通用语言**（过去式给事件、祈使式给命令）。
6. 写事件：每个成功的命令后都有事实输出。
7. 设计仓储：**以聚合为单位**的 Get/Save，一次事务只改一个聚合。
8. 写**聚合级测试**：直接 new 聚合 → 调方法 → 断言状态与事件；**不连数据库**。



#### 3.2 你可能会问（预答）



- Q1：聚合能跨很多表吗？

  可以。聚合是业务边界，不是数据表边界；多表同事务保存即可。表只是实现细节。

- Q2：聚合之间能互相引用吗？

  只能引用对方的 ID。不要持有对方对象引用，更不要跨聚合直接改别人的内部状态。沟通靠事件或应用层编排。

- Q3：查询要拼很多聚合怎么办？

  走查询模型/读视图（CQRS 的读）；为展示优化，允许反范式；保持写模型简洁。

- Q4：“版本与并发”是不是 DDD 概念？

  乐观锁版本号不是 DDD 的概念，但它是实现不变量时常用的工程手段：在并发写入下防止“最后写入者把别人改动覆盖”。

- **Q5：领域服务与应用服务到底怎么分？**

    - **领域服务**：仍然是**业务话语**，只是跨聚合/需外部能力（如定价）；可以被聚合方法调用或被应用服务编排调用。
    - **应用服务**：**技术话语**，做编排（加载/调用/保存/发布），不写业务判断。



## 第三部分：治理与反模式 —— 持续保持架构健康



> **本章定调**：与其背 20 条口号，不如牢牢记住少数几条能救火的“红线”和一套可复用的**处方流程**。本章分三层优先级（P0→P2），每条都按**症状 → 机理 → 后果 → 处方**的结构讲透。



### 第 1 章：反模式治理手册

#### 1.1 P0（禁止项 | 红线）：一旦出现，优先级压过一切

##### 跨上下文强一致（分布式大事务/2PC）

- **症状**：一次操作必须同时锁住“派单、行程、结算、支付”多个上下文；代码里冒出“全局事务/两阶段提交”。

- **为什么**：把“业务流程”当成“数据库事务”处理；边界没有把一致性要求分层。

- **后果**：延迟与故障传染、回滚地狱、扩展性被掐死。

- **处方**：



1. 给这条链路画**事件时序图**，把每步变成“**局部事务 + 领域事件**”；
2. 为每一步定义**补偿动作**（Saga）：支付失败→生成欠费账、通知；
3. 建 **Outbox**（同事务写业务+事件），消费者幂等、可重试；
4. 明确**SLA**：最终一致允许多久、用户看到什么。



- **验收**：任何跨上下文调用都可**独立失败而不损坏不变量**；链路具备重放能力。

- **网约车例**：完单不再直接“同时入账+扣款”，而是 TripCompleted → 结算生成账单 → 支付网关扣款 → 失败触发“欠费账 + 催收”。

##### 共享数据库写入（多个上下文写同一表）

- **症状**：结算和定价写同一张 orders；谁都能改谁的字段。

- **为什么**：把“数据归属”当成“大家的公共场地”。

- **后果**：边界形同虚设，迁移困难，任何 Schema 调整都是全员出动。

- **处方**：



1. 明确**写入归属**：一张表的写入只属于一个上下文；
2. 其他上下文如需数据，走**事件订阅**或**只读副本**；
3. 逐步抽离：先把读写拆开，再迁出写路径（绞杀榕树）。



- **验收**：每张可写表都有**唯一“责任上下文”**；其他上下文通过**只读接口/读库**访问。

- **例**：定价只写 quoted_fares 表；结算只写 settlements；双方通过事件对齐。

##### 边界未稳的过早微服务化

- **症状**：上线第 3 周就 15 个服务；跨服务调用链像毛线团。

- **为什么**：错把“服务数量”当“工程成熟度”；建模尚未稳定。

- **后果**：网络放大脆弱性，故障定位困难，一致性问题倍增。

- **处方**：



1. **模块化单体**先行：以**限界上下文**为模块边界；
2. 只有当出现**独立扩缩容/发布节奏差异/合规隔离**时才拆；
3. 拆前先做**契约与消息 Schema 版本化**。



- **验收**：能在单体内开关“服务化适配层”，并以契约测试保障拆分前后一致。

- **例**：先把“派单”做成包级边界（只暴露端口），吞吐与团队独立性确立后再单独部署。

##### 贫血模型（聚合无不变量，业务全在脚本里）

- **症状**：一堆 UpdateXXX()；规则散落在应用服务/控制器里。

- **为什么**：把对象当“表的影子”，没让“方法”守住不变量。

- **后果**：任何路径都能绕过规则；测试必须连库跑、成本高。

- **处方**：



1. 先写**不变量清单**；
2. 把每条业务动作收敛为**聚合根方法**（先校验→再改→发事件）；
3. 应用服务只做**编排**（Load→Call→Save→Publish）。



- **验收**：聚合级单元测试可**不连数据库**就覆盖主要业务。

- **例**：Trip.AssignDriver/LockFare/Complete 取代“散装 if 脚本”。



##### 通用语言失效（同词不同义且未隔离）

- **症状**：price 在定价=报价，在结算=应收；大家混用一个字段名。

- **为什么**：缺少语言边界，图省事直接复用外部模型。

- **后果**：沟通偏差、数据歧义、错账事故。

- **处方**：



1. 按上下文重命名与封装：QuotedFare vs PayableAmount；
2. 强势上游接入建立 **ACL（防腐层）** 做术语翻译；
3. 为集成定义**Published Language**（发布语言/Schema）。



- **验收**：任何上下文内部术语**唯一含义**；跨边界都通过 DTO/事件进行**显式翻译**。

- **例**：支付回调的“金额”统一转换为结算上下文的 PayableAmount，并记录来源与汇率。



#### 1.2 P1（高风险项 | 谨慎使用与持续监控）

##### 超大聚合（God Aggregate）

- **症状**：一个聚合挂十几个实体；每次写冲突像早高峰地铁。
- **为什么**：以“方便一次取全”为半径，而不是以“不变量半径”。
- **后果**：并发冲突多、吞吐低、锁粒度粗。
- **处方**：以**不变量为刀**重切：哪些状态必须“要么一起成要么一起败”留内部，其余拆出去，用事件协作。
- **验收**：写冲突率显著下降；聚合方法关注点更集中。
- **例**：把司机可用性从 Trip 聚合中拆出，靠 DriverAssigned/Released 事件来回对齐。



##### 大喇叭事件（过度事件化）

- **症状**：任何小状态都发事件；消费者森林。
- **为什么**：把事件当“同步调用的替身”。
- **后果**：可观测性差，调试困难，耦合“隐性化”。
- **处方**：只发布**有领域意义的事实**；为每类事实定义**路由与订阅边界**；建立**事件契约测试**与**死信处理**。
- **验收**：事件图谱清晰、消费者有名单、死信<0.1%。
- **例**：保留 TripCompleted、DriverAssigned，去掉“UI 已刷新”之类非领域事实。



##### 不可演进的消息/Schema

- **症状**：事件一改字段全线挂；无版本、无弃用标记。
- **处方**：**向后兼容**为王：新增不删、弃用先标记；Schema 版本化与契约测试。
- **验收**：新旧消费者可并行两周以上无故障。
- **例**：TripCompleted.v2 增加 DistanceKm，旧消费者忽略即可。



##### ACL 缺失导致模型污染

- **症状**：上游（支付/地图）直接把自己的对象塞进你领域。
- **处方**：在边界加 **ACL**：适配器 + 翻译器 + 映射表；外部异常语义也做映射。
- **验收**：领域层无第三方 SDK/类型；只有你的 DTO/VO。
- **例**：第三方支付错误码 X_43 翻译为你领域的 CardDeclined。



##### 查询挟持写模型

- **症状**：为了一个报表，把跨上下文的连接查询塞进写模型/聚合仓储。
- **处方**：读写分离：把它放到**查询模型/读库**，必要时事件驱动物化视图。
- **验收**：写模型仓储只处理**一个聚合**的存取。
- **例**：行程+司机评分报表通过读模型构建，不侵入 Trip 写路径。



#### 1.3 P2（“味道”与亚健康 | 建议优化）

- **以表为边界切上下文** → 以**语言与不变量**重切边界。
- **通用仓储/泄露 ORM** → 仓储以聚合为单位，返回领域对象，不回传游标/会话。
- **过度 CQRS/滥用事件溯源** → 从“轻 CQRS”起步；只有审计/回放刚需时再上 ES。
- **服务层层套娃**（应用服务里调 5 个“领域脚本”）→ 把规则拉回聚合/领域服务，应用只编排。
- **术语无文档** → 每个上下文维护**术语表 + 禁用词清单**（显式写出“我们这里不叫它 X”）。



### 第 2 章：决策与演进工具箱

#### 2.1 两棵决策树（把复杂选择变成可操作流程）



**A. 这是不是一个聚合？**

1. 这个操作是否需要同时修改多处状态**要么全成要么全败**？若“是”，倾向一个聚合。
2. 是否存在**必须一起守住的不变量**？若“是”，同聚合。
3. 高并发下是否会频繁写冲突？若“是”，考虑**拆小**并用事件协调。

**B. 要不要拆微服务？**

1. 这个上下文是否需要**独立扩缩容**或有**合规隔离**？

2. 发布频率/回滚策略与其他上下文差异显著？

3. 契约/Schema 是否已版本化并稳定？

   三条里至少满足两条，再拆。否则继续模块化单体。



#### 2.2 场景化处方（三种高频真问题）



- **场景一：接入第三方支付，术语乱入**
    - **风险**：顺从者模式（Conformist）把上游术语照搬进领域。
    - **处方**：
        1. 采用 **ACL**：GatewayTxn → PaymentReceipt（你的词汇）；
        2. 定义 **Published Language**：PaymentRequested/PaymentSucceeded/Failed 事件；
        3. 失败语义做**等价类映射**（超时/拒付/余额不足）。
    - **验收**：领域层无第三方类型；回调入境先过翻译器。
- **场景二：增长期要把“派单”独立成服务**
    - **风险**：边界未稳、事件/接口未固化，拆完更脆。
    - **处方**：
        1. 在单体内先抽**端口**与**DTO/事件**，跑契约测试；
        2. 为“超时、重试、熔断、隔离”预设默认策略；
        3. 上线后用**影子流量**对比读模型一致性。
    - **验收**：切流后 1 周内 SLO 达标、事件对齐率 > 99.9%。
- **场景三：数据团队要“直接连库”做报表**
    - **风险**：写路径被迫兼容外部查询；边界被架空。
    - **处方**：
        1. 提供**只读副本/数据集市**；
        2. 关键事实通过**事件 CDC** 写入数仓；
        3. 对外只承诺**发布语言**的 Schema，不承诺内部表结构。
    - **验收**：写库只被领域服务写；外部只读连接到只读库/数据集市。



#### 2.3 运行期治理：度量、告警与“看得见的健康”

**核心 SLI/SLO（建议线）**

- 事件投递成功率 ≥ 99.9%，端到端可用性 99.5%+。
- 幂等冲突率 < 0.1%（按 (AggregateID, Version) 去重统计）。
- 聚合写冲突率（乐观锁失败）< 2% 且有指数退避重试。
- 跨上下文链路“最终一致延迟 P95”≤ 60s（按业务定义）。
- 死信队列为 0，或 10 分钟内自动回补率 ≥ 95%。

把这些指标挂到看板，任何重构是否见效，一目了然。



#### 2.4 反脆弱演练（Game Day）：把坑变成肌肉记忆

- **演练 1**：支付网关 10% 持续超时 → 观测 Saga 补偿与催收是否工作。
- **演练 2**：事件总线丢包 0.5% → Outbox 回补、去重统计、读模型延迟是否触发报警。
- **演练 3**：定价 Schema 升级 v2 → 旧消费者并行两周、灰度切换、契约测试拦截不兼容变更。



### **小结（把记忆负担降到最低）**

- 先记**五条红线（P0）**：分布式大事务、共享写库、早拆微服务、贫血模型、语言混淆。
- 再盯**三件治理硬功**：**不变量驱动的聚合**、**事件 + 补偿**、**发布语言/契约测试**。
- 一切都落回“**能失败而不坏账**、**可观测且可重放**、**演进不惊天动地**”。